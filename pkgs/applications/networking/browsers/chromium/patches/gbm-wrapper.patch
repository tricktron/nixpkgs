diff --git a/ui/gfx/linux/gbm_wrapper.cc b/ui/gfx/linux/gbm_wrapper.cc
index 1b5d52cbb3..1a1e898216 100644
--- a/ui/gfx/linux/gbm_wrapper.cc
+++ b/ui/gfx/linux/gbm_wrapper.cc
@@ -2,13 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <cstddef>
+
+#include "base/files/file_path.h"
+#include "base/files/scoped_file.h"
+#include "base/native_library.h"
 #ifdef UNSAFE_BUFFERS_BUILD
 // TODO(crbug.com/354829279): Remove this and convert code to safer constructs.
 #pragma allow_unsafe_buffers
 #endif
 
-#include "ui/gfx/linux/gbm_wrapper.h"
-
 #include <gbm.h>
 #include <sys/mman.h>
 
@@ -26,6 +29,7 @@
 #include "ui/gfx/linux/drm_util_linux.h"
 #include "ui/gfx/linux/gbm_buffer.h"
 #include "ui/gfx/linux/gbm_device.h"
+#include "ui/gfx/linux/gbm_wrapper.h"
 #include "ui/gfx/linux/scoped_gbm_device.h"
 
 #if !defined(MINIGBM)
@@ -40,6 +44,39 @@ namespace ui {
 namespace gbm_wrapper {
 namespace {
 
+static constexpr base::FilePath::CharType kGbmSoName[] =
+    FILE_PATH_LITERAL("libgbm.so.1");
+static constexpr char kGbmBoGetFdForPlaneFn[] = "gbm_bo_get_fd_for_plane";
+using GbmGetPlaneForFdFn = int (*)(gbm_bo*, int);
+
+struct GbmDynamicBinding {
+  GbmDynamicBinding() {
+    base::NativeLibraryLoadError error;
+    lib_handle = base::LoadNativeLibrary(base::FilePath(kGbmSoName), &error);
+    if (!lib_handle) {
+      LOG(ERROR) << "Failed to load GBM library: " << kGbmSoName << ": "
+                 << error.ToString();
+      return;
+    }
+
+    gbm_bo_get_fd_for_plane_ptr = reinterpret_cast<GbmGetPlaneForFdFn>(
+        base::GetFunctionPointerFromNativeLibrary(lib_handle,
+                                                  kGbmBoGetFdForPlaneFn));
+    if (!gbm_bo_get_fd_for_plane_ptr) {
+      LOG(INFO) << kGbmBoGetFdForPlaneFn << " not found in " << kGbmSoName;
+    }
+  }
+
+  ~GbmDynamicBinding() = default;
+  base::NativeLibrary lib_handle = nullptr;
+  GbmGetPlaneForFdFn gbm_bo_get_fd_for_plane_ptr = nullptr;
+};
+
+static GbmDynamicBinding& GetGbmBinding() {
+  static GbmDynamicBinding binding;
+  return binding;
+}
+
 uint32_t GetHandleForPlane(struct gbm_bo* bo, int plane) {
   return gbm_bo_get_handle_for_plane(bo, plane).u32;
 }
@@ -60,12 +97,21 @@ base::ScopedFD GetPlaneFdForBo(gbm_bo* bo, size_t plane) {
 #if defined(MINIGBM)
   return base::ScopedFD(gbm_bo_get_plane_fd(bo, plane));
 #else
-  const int plane_count = GetPlaneCount(bo);
-  DCHECK(plane_count > 0 && plane < static_cast<size_t>(plane_count));
+  GbmGetPlaneForFdFn fn = GetGbmBinding().gbm_bo_get_fd_for_plane_ptr;
+  if (fn) {
+    // Gbm library has per-plane fd support.
+    return base::ScopedFD(fn(bo, base::checked_cast<int>(plane)));
+  }
+
+  LOG(ERROR)
+      << "Using drm ioctl fallback which might not be supported on all drivers";
 
   // System linux gbm (or Mesa gbm) does not provide fds per plane basis. Thus,
   // get plane handle and use drm ioctl to get a prime fd out of it avoid having
   // two different branches for minigbm and Mesa gbm here.
+  const int plane_count = GetPlaneCount(bo);
+  DCHECK(plane_count > 0 && plane < static_cast<size_t>(plane_count));
+
   gbm_device* gbm_dev = gbm_bo_get_device(bo);
   int dev_fd = gbm_device_get_fd(gbm_dev);
   DCHECK_GE(dev_fd, 0);
@@ -152,12 +198,14 @@ class Buffer final : public ui::GbmBuffer {
     return ui::GetBufferFormatFromFourCCFormat(format_);
   }
   bool AreFdsValid() const override {
-    if (handle_.planes.empty())
+    if (handle_.planes.empty()) {
       return false;
+    }
 
     for (const auto& plane : handle_.planes) {
-      if (!plane.fd.is_valid())
+      if (!plane.fd.is_valid()) {
         return false;
+      }
     }
     return true;
   }
@@ -493,8 +541,9 @@ class Device final : public ui::GbmDevice {
 
 std::unique_ptr<GbmDevice> CreateGbmDevice(int fd) {
   gbm_device* device = gbm_create_device(fd);
-  if (!device)
+  if (!device) {
     return nullptr;
+  }
   return std::make_unique<gbm_wrapper::Device>(device);
 }
 
